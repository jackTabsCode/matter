"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[893],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),u=o,h=p["".concat(c,".").concat(u)]||p[u]||m[u]||r;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},92725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(87462),o=(n(67294),n(3905));const r={},i="State Machines",s={unversionedId:"BestPractices/StateMachines",id:"BestPractices/StateMachines",title:"State Machines",description:"A state machine is a general programming term that describes a system that can only be in one of a few known states, and the states it can change into are also all known and defined.",source:"@site/docs/BestPractices/StateMachines.md",sourceDirName:"BestPractices",slug:"/BestPractices/StateMachines",permalink:"/matter/docs/BestPractices/StateMachines",draft:!1,editUrl:"https://github.com/jackTabsCode/matter/edit/main/docs/BestPractices/StateMachines.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Derived state",permalink:"/matter/docs/BestPractices/DerivedState"},next:{title:"Using CollectionService tags",permalink:"/matter/docs/Guides/CollectionService"}},c={},l=[{value:"Components as state machines",id:"components-as-state-machines",level:2},{value:"Adding another layer",id:"adding-another-layer",level:2}],d={toc:l},p="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"state-machines"},"State Machines"),(0,o.kt)("p",null,"A state machine is a general programming term that describes a system that can only be in one of a few known states, and the states it can change into are also all known and defined."),(0,o.kt)("p",null,"For example, you could define a Jack-in-the-Box as a state machine, with the following states:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Resting"),(0,o.kt)("li",{parentName:"ul"},"Winding up"),(0,o.kt)("li",{parentName:"ul"},"Popped out"),(0,o.kt)("li",{parentName:"ul"},"Resetting")),(0,o.kt)("p",null,"It might help if you think of these states as animations that play on a 3D model."),(0,o.kt)("p",null,"By default, the Jack-in-the-Box is resting. But if you start winding it up, it can transition into the Winding Up state."),(0,o.kt)("p",null,"At this point, it could either go back to resting, or it can go to popped out!"),(0,o.kt)("p",null,"Once it's popped out, we can't go back to resting or winding up. But we can push it back into the box (resetting), which then puts it back into the Resting state."),(0,o.kt)("p",null,"We can imagine these states as a graph, with the transitions between states defined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Resting <--\x3e Winding Up --\x3e Popped out --\x3e Resetting\n    ^                                       |\n    |---------------------------------------*\n")),(0,o.kt)("p",null,"You can go from Resting to Winding Up, from Winding up to Popped out, but you can't go from Popped out to Winding up."),(0,o.kt)("h2",{id:"components-as-state-machines"},"Components as state machines"),(0,o.kt)("p",null,"Now that you (hopefully) understand state machines, we can relate this to components in an ECS."),(0,o.kt)("p",null,"While some components are mostly static or just update as data changes (like a component that holds the player's current Walk Speed), other components might be a little bit more complex."),(0,o.kt)("p",null,"Imagine we had a car that we want to drive from point A to point B, then from point B to point C, then from C to D, etc. How do we store what point the car is currently at, and which to go to next?"),(0,o.kt)("p",null,"This is where treating your component as a state machine come in. You can have your component data represent a state in a state machine, and your system code progresses that component one step forward, into the next state."),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"Car")," component could have an array of ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector3"),"s in it, the points we want to visit:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"world:spawn(Car({\n    destinations = {Vector3.new(0, 0, 0), Vector3.new(10, 0, 5), Vector3.new(-5, 2, 3)}\n}))\n")),(0,o.kt)("p",null,"In our system code, we can drive the car towards one of the points, and when it reaches its destination, remove that item from the list and start going towards the next."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"for id, car, model in world:query(Car, Model) do\n    local currentPosition = model.model.PrimaryPart.Position\n\n    if (currentPosition - car.destinations[1]).magnitude < 2 then -- Arrived\n        table.remove(car.destinations, 1)\n\n        if #car.destinations == 0 then\n            world:despawn(id)\n            continue\n        end\n    end\n\n    model.model.PrimaryPart.BodyPosition.Position = car.destinations[1] --example\nend\n")),(0,o.kt)("p",null,'In this way, our system "steps" our component forward in time, modifying it when necessary.'),(0,o.kt)("h2",{id:"adding-another-layer"},"Adding another layer"),(0,o.kt)("p",null,"We can make this a little bit more complicated if we make the car wait at each destination once it arrives."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'world:spawn(Car({\n    destinations = {Vector3.new(0, 0, 0), Vector3.new(10, 0, 5), Vector3.new(-5, 2, 3)},\n    mode = "driving"\n}))\n\n-----\n\nfor id, car, model in world:query(Car, Model) do\n    if car.mode == "waiting" then\n        if os.clock() - car.startedWaiting > 5 then -- Wait 5 seconds\n            world:insert(id, car:patch({\n                mode = "driving",\n                startedWaiting = Matter.None\n            }))\n        end\n    elseif car.mode == "driving" then\n        if #car.destinations == 0 then\n            world:despawn(id)\n            continue\n        end\n\n        local currentPosition = model.model.PrimaryPart.Position\n\n        if (currentPosition - car.destinations[1]).magnitude < 2 then -- Arrived\n            table.remove(car.destinations, 1)\n\n            world:insert(id, car:patch({\n                mode = "waiting",\n                startedWaiting = os.clock()\n            }))\n\n            continue\n        end\n\n        model.model.PrimaryPart.BodyPosition.Position = car.destinations[1] --example\n    end\nend\n')),(0,o.kt)("p",null,"Now, we've added another layer to our Car component: a ",(0,o.kt)("inlineCode",{parentName:"p"},"mode"),' property, that tells our code if the car is waiting or driving. You can see how this could get even more complex, adding other modes, arrays to drain, and other state that allows our system to "step" our component forward in time.'))}m.isMDXComponent=!0}}]);