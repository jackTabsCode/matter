"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[645],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),h=o,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||r;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},42875:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={sidebar_position:2,title:"Core Concepts"},i="Core Concepts",l={unversionedId:"Concepts",id:"Concepts",title:"Core Concepts",description:"This page goes over some core concepts that you should be familiar with in order to use Matter and effectively write code using an ECS.",source:"@site/docs/Concepts.md",sourceDirName:".",slug:"/Concepts",permalink:"/matter/docs/Concepts",draft:!1,editUrl:"https://github.com/jackTabsCode/matter/edit/main/docs/Concepts.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Core Concepts"},sidebar:"defaultSidebar",previous:{title:"Matter",permalink:"/matter/docs/intro"},next:{title:"Installation",permalink:"/matter/docs/Installation"}},s={},p=[{value:"Entities",id:"entities",level:2},{value:"Components",id:"components",level:2},{value:"World",id:"world",level:2},{value:"Systems",id:"systems",level:2},{value:"Loop",id:"loop",level:2},{value:"Topologically-aware functions",id:"topologically-aware-functions",level:2}],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"core-concepts"},"Core Concepts"),(0,o.kt)("p",null,"This page goes over some core concepts that you should be familiar with in order to use Matter and effectively write code using an ECS."),(0,o.kt)("h2",{id:"entities"},"Entities"),(0,o.kt)("p",null,"An entity represents something in your game. It might be a player character, an enemy, or a tree. Generally, you will have one entity per thing you want to represent in your game. In Matter (as well as a typical ECS), an entity is just a unique number."),(0,o.kt)("h2",{id:"components"},"Components"),(0,o.kt)("p",null,"Components are pieces of data that you can attach to entities. Since entities are just numbers, all the information about an entity is stored in its components. Components are data structures that you define and reuse across many different entities."),(0,o.kt)("p",null,"For example, you might define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," component, which has two fields: ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"max"),". You can then reuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," component across many different entities. You might add it to both player entities and enemy entites. Or even a tree, if you have trees that can take damage."),(0,o.kt)("p",null,"An important distinction between a more object-oriented way of thinking and ECS is that instead of having an object that has methods and fields (",(0,o.kt)("inlineCode",{parentName:"p"},"Enemy"),' class to represent an enemy), entities are much more flexible. There is really no such thing as an "enemy entity" or "tree entity". Instead, there are entities that have the ',(0,o.kt)("inlineCode",{parentName:"p"},"Enemy")," component, or have the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tree")," component. It's possible, then, for there to be an entity that has both the ",(0,o.kt)("inlineCode",{parentName:"p"},"Enemy")," ",(0,o.kt)("em",{parentName:"p"},"and")," ",(0,o.kt)("inlineCode",{parentName:"p"},"Tree")," components. You might also give it the ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," component if you want it to be able to take damage."),(0,o.kt)("p",null,"So, instead of thinking about things based on what they are, we instead think of the in terms of characteristics that they have. This creates a much more flexible data model and enables code reuse in ways that are difficult to achieve with an inheritance-based object-oriented model."),(0,o.kt)("h2",{id:"world"},"World"),(0,o.kt)("p",null,"A World is an object that contains all of your entities and all of their components. You will usually only have one World in your game. You create it when your game starts. (See: ",(0,o.kt)("a",{parentName:"p",href:"/docs/GettingStarted"},"GettingStarted"),")"),(0,o.kt)("p",null,"You can create entities in your World by using the ",(0,o.kt)("a",{parentName:"p",href:"/api/World#spawn"},(0,o.kt)("inlineCode",{parentName:"a"},"World:spawn"))," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local newEntityId = world:spawn(\n    Enemy(),\n    Health({\n        current = 100,\n        max = 100,\n    }),\n    Name({\n        name = "Evil Tree"\n    }),\n    Tree({\n        type = "oak"\n    })\n)\n')),(0,o.kt)("p",null,"Now, the new entity has been created with all of our specified components. We got back the new entity ID (just a number) and stored it in the variable ",(0,o.kt)("inlineCode",{parentName:"p"},"newEntityid"),"."),(0,o.kt)("p",null,"We can get a specific component like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local nameComponent = world:get(newEntityId, Name)\n\nprint(nameComponent.name)\n")),(0,o.kt)("p",null,"Here's a quick, incomplete reference of the things you can do:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Method"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"spawn")),(0,o.kt)("td",{parentName:"tr",align:null},"spawn a new entity with given components")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"insert")),(0,o.kt)("td",{parentName:"tr",align:null},"Add new or replace an existing  component on an existing entity")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"get")),(0,o.kt)("td",{parentName:"tr",align:null},"Get a specific component or set of components from an existing entity")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"remove")),(0,o.kt)("td",{parentName:"tr",align:null},"Remove a component from an existing entity.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"despawn")),(0,o.kt)("td",{parentName:"tr",align:null},"Remove all components from an entity and delete the entity.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"contains")),(0,o.kt)("td",{parentName:"tr",align:null},"Check whether or not an entity still exists in the world.")))),(0,o.kt)("p",null,"Check out the ",(0,o.kt)("a",{parentName:"p",href:"/api/World"},(0,o.kt)("inlineCode",{parentName:"a"},"World")," API reference")," to see everything else you can do!"),(0,o.kt)("h2",{id:"systems"},"Systems"),(0,o.kt)("p",null,"Since components are just data, we need a way to actually... do things! This is where Systems come in. A system is just a function that runs every frame in a specific order alongside your other systems. Typically, a system only does one job, using a specific set of components."),(0,o.kt)("p",null,"We can reuse our ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," component from earlier. Let's say that in our game, we want anything with health to regenerate its HP over time. Remember, we don't care about what the things actually are that we are dealing with here. We don't care if it's a player, an enemy, or a tree: all we know is that it has health."),(0,o.kt)("p",null,'A good way to name systems is by declaring something about the world that they do. In this case: "Health Regenerates."'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="healthRegenerates.lua"',title:'"healthRegenerates.lua"'},"for id, health in world:query(Health) do\n    if health.current < health.max then\n        world:insert(id, health:patch({\n            -- Regenerate 0.1% of maximum health per frame\n            current = math.min(health.max, health.current + (health.max * 0.001))\n        })\n    end\nend\n")),(0,o.kt)("p",null,"In the above code sample, we use the ",(0,o.kt)("a",{parentName:"p",href:"/api/World#query"},"World:query")," method to loop over everything in the world that has ",(0,o.kt)("inlineCode",{parentName:"p"},"Health"),", and regenerate some."),(0,o.kt)("p",null,"You can also query for multiple components at once, i.e. if you only wanted to select ",(0,o.kt)("inlineCode",{parentName:"p"},"Player"),"s with ",(0,o.kt)("inlineCode",{parentName:"p"},"Health"),". Then, you will only get entities that have both components."),(0,o.kt)("p",null,"Systems can also interact with Roblox Instances and change things through side effects. The ",(0,o.kt)("a",{parentName:"p",href:"/docs/BestPractices/Reconciliation"},"Reconciliation")," page goes over this in more detail."),(0,o.kt)("h2",{id:"loop"},"Loop"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Loop")," object in Matter is a simple way to handle running your Systems in the same order every frame. This is covered on the ",(0,o.kt)("a",{parentName:"p",href:"/docs/GettingStarted"},"GettingStarted")," page. It's not technically required, but makes setting up Matter much easier and enables some topologically-aware features."),(0,o.kt)("h2",{id:"topologically-aware-functions"},"Topologically-aware functions"),(0,o.kt)("p",null,"Many functions in matter are ",(0,o.kt)("em",{parentName:"p"},"topologically-aware"),": this means that they store some state which is referenced by the file and line number where the function is called from. ",(0,o.kt)("inlineCode",{parentName:"p"},"useEvent"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"useThrottle"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"World:queryChanged"),' are all examples. This works in a similar way to "hooks" from React/Roact, and so we often refer to topologically-aware functions with the term "hook".'),(0,o.kt)("p",null,"Under the hood, Matter creates and stores state that these functions use and references them by the call location, in contrast to having to come up with a name or place to store it yourself. The script name and line number become the way that we identify the state storage for whatever function you called. This only works when your Systems are invoked by a Matter ",(0,o.kt)("inlineCode",{parentName:"p"},"Loop"),"."),(0,o.kt)("p",null,"You can learn more about this and even implement your own topologically-aware functions on the ",(0,o.kt)("a",{parentName:"p",href:"/api/Matter#useHookState"},(0,o.kt)("inlineCode",{parentName:"a"},"useHookState")," docs"),"."))}d.isMDXComponent=!0}}]);